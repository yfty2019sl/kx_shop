var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { isVNode, provide, reactive, getCurrentInstance, } from 'vue';
export function flattenVNodes(children) {
    var result = [];
    var traverse = function (children) {
        if (Array.isArray(children)) {
            children.forEach(function (child) {
                var _a;
                if (isVNode(child)) {
                    result.push(child);
                    if ((_a = child.component) === null || _a === void 0 ? void 0 : _a.subTree) {
                        traverse(child.component.subTree.children);
                    }
                    if (child.children) {
                        traverse(child.children);
                    }
                }
            });
        }
    };
    traverse(children);
    return result;
}
// sort children instances by vnodes order
export function sortChildren(parent, publicChildren, internalChildren) {
    var vnodes = flattenVNodes(parent.subTree.children);
    internalChildren.sort(function (a, b) { return vnodes.indexOf(a.vnode) - vnodes.indexOf(b.vnode); });
    var orderedPublicChildren = internalChildren.map(function (item) { return item.proxy; });
    publicChildren.sort(function (a, b) {
        var indexA = orderedPublicChildren.indexOf(a);
        var indexB = orderedPublicChildren.indexOf(b);
        return indexA - indexB;
    });
}
export function useChildren(key) {
    var publicChildren = reactive([]);
    var internalChildren = reactive([]);
    var parent = getCurrentInstance();
    var linkChildren = function (value) {
        var link = function (child) {
            if (child.proxy) {
                internalChildren.push(child);
                publicChildren.push(child.proxy);
                sortChildren(parent, publicChildren, internalChildren);
            }
        };
        var unlink = function (child) {
            var index = internalChildren.indexOf(child);
            publicChildren.splice(index, 1);
            internalChildren.splice(index, 1);
        };
        provide(key, __assign({ link: link,
            unlink: unlink, children: publicChildren, internalChildren: internalChildren }, value));
    };
    return {
        children: publicChildren,
        linkChildren: linkChildren,
    };
}
